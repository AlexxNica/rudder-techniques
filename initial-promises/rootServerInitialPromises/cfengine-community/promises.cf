#####################################################################################
# Copyright 2011 Normation SAS
#####################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, Version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#####################################################################################

#######################################################
#
# promises.cf
#
#######################################################
body common control {

    inputs => {       
        "common/1.0/cf-served.cf","common/1.0/cfengine_stdlib.cf","common/1.0/rudder_lib.cf","common/1.0/process_matching.cf","common/1.0/internal_security.cf","common/1.0/site.cf","common/1.0/update.cf","distributePolicy/1.0/propagatePromises.cf","distributePolicy/1.0/rsyslogConf.cf","distributePolicy/1.0/initCheck.cf","distributePolicy/1.0/postgresCheck.cf","distributePolicy/1.0/logrotateCheck.cf","distributePolicy/1.0/integrityCheck.cf","distributePolicy/1.0/networkCheck.cf","distributePolicy/1.0/aliveCheck.cf","distributePolicy/1.0/passwordCheck.cf"
    };

    bundlesequence => { @(va.bs),"setup_debian_backports","install_rsyslogd","propagatePromises","sendInventoryToCmdb","root_init_check","root_postgres_check","root_logrotate_check","root_integrity_check","root_networks_check","root_alive_check","root_password_check_file",,"root_password_check_ldap","root_password_check_psql","root_password_check_dav","root_password_restart_jetty" , @(va.end)};
    
	output_prefix => "rudder"; 
    
}

bundle common va {
  vars:
    "bs" slist => { "startExecution", "clean_red_button", "update", "set_red_button", "internal_security", "process_matching", "check_cf_processes", "check_uuid", "check_cron_daemon", "garbage_collection"
     };


	"end" slist => { "endExecution" };


# definition of the machine roles
classes: 
	# Abort if no uuid is defined
	"should_not_continue" expression not => fileexists("${g.uuid_file}");
	# Policy Server is a machine which delivers promises
    "policy_server" expression => strcmp("root","$(g.uuid)");
	# Root Server is the top policy server machine
    "root_server" expression => strcmp("root","$(g.uuid)");
}

#########################################################
# Control execution
#########################################################
bundle agent startExecution {
  reports:
   linux|windows::
       "@@Common@@log_info@@hasPolicyServer-root@@common-root@@4@@common@@StartRun@@$(g.execRun)##$(g.uuid)@#Start execution";
}

bundle agent endExecution {
  reports:
   linux|windows::
       "@@Common@@log_info@@hasPolicyServer-root@@common-root@@4@@common@@EndRun@@$(g.execRun)##$(g.uuid)@#End execution";
}

##########################################################
# Red Button part.
# When the file $(sys.workdir)/inputs/stop exists, we must stop the
# execution of the agent on all client machines
##########################################################
bundle agent clean_red_button() {
  commands:
	safe.policy_server::
 		"$(sys.workdir)/bin/cf-runagent"
 			args => "-Dsafe",
 			comment => "Propagate the safe information to children";
 			
  files:
   safe.policy_server::
	"/var/rudder/share/[a-f0-9A-F\-]+/rules/cfengine-(community|nova)/stopFile"
		delete => tidy,
		comment => "Deleting the stop file on clients promises, cfengine is good to go";
             
	safe.!policy_server::
        "${sys.workdir}/inputs/stopFile" 
             delete => tidy,
             comment => "Deleting the stop file, cfengine is good to go";
             
   reports:
     safe::
		"@@Common@@result_repaired@@hasPolicyServer-root#@common-root##$(g.uuid)@#Authorizing Cfengine to restart";
}

bundle agent set_red_button() {
  classes:
	policy_server::
		"danger" expression => fileexists("/var/rudder/share/root/stopFile");
  methods:
  	danger::
  		"any" usebundle => setStopFile;
  	
  	danger.policy_server::
  		"any" usebundle => stopClients;
}

bundle agent setStopFile {
 files:
    danger.!policy_server::
        "${sys.workdir}/inputs/stopFile" 
            create => "true";
    danger.policy_server::
        "/var/rudder/share/[a-f0-9A-F\-]+/rules/cfengine-(community|nova)/stopFile"
        create => "true";
  
  reports:
     danger.!policy_server::
		"@@Common@@result_repaired@@hasPolicyServer-root#@common-root##$(g.uuid)@#Creating stop file";
     danger.policy_server::
		"@@Common@@result_repaired@@hasPolicyServer-root#@common-root##$(g.uuid)@#Creating stop files for clients";
    
}

bundle agent stopClients {
 classes:
	policy_server::
		"danger" expression => fileexists("/var/rudder/share/root/stopFile");

 commands:
 	danger.policy_server::
 		"$(sys.workdir)/bin/cf-runagent"
 			args => "-Ddanger",
 			comment => "Propagate the danger information to children";  
 
 reports:
     danger.policy_server::
		"@@Common@@result_repaired@@hasPolicyServer-root#@common-root##$(g.uuid)@#gStopping all Cfengine operation";
 
}

bundle agent check_red_button_status() {
	classes:
		!policy_server::
			"should_not_continue" expression => fileexists("${sys.workdir}/inputs/stopFile");
}


###################################################
# Check that CFengine services are up 
###################################################
bundle agent check_cf_processes {

processes:

  "$(sys.workdir)/bin/cf-serverd"  restart_class => "start_server";
  "$(sys.workdir)/bin/cf-execd"    restart_class => "start_executor";

commands:

	start_server::
		"$(sys.cf_serverd)",
			action => u_ifwin_bg,
			classes => outcome("server");
	
	start_executor::
		"$(sys.cf_execd)",
			action => u_ifwin_bg,
			classes => outcome("executor");

}

#######################################################
# UUID file enforcing

bundle agent check_uuid {
  files:
	"${g.uuid_file}"
		create    => "true",
       		edit_line => enforce_content("${g.uuid}"),
       		edit_defaults => empty_backup,
		perms => m("644"),
       		comment => "Setting the uuid variable in a machine";
			
}

#######################################################
# Check if the cron daemon is running
# This only works with unix flavoured systems too

bundle agent check_cron_daemon {

    vars:

        (debian|SuSE)::

            "cron_bin" string => "/usr/sbin/cron";
            "cron_restartcmd" string => "/etc/init.d/cron restart";

        redhat::

            "cron_bin" string => "crond";
            "cron_restartcmd" string => "/etc/init.d/crond restart";

    processes:

            "$(cron_bin)"
                restart_class => "restart_crond";

    commands:

        restart_crond::

            "$(cron_restartcmd)"

                comment => "Restarting crond",
                classes => class_trigger("crond_restarted" , "crond_failed", "crond_ok");

    reports:

        crond_failed::
            "@@Common@@result_error@@&TRACKINGKEY&@@CRON Daemon@@None@@$(g.execRun)##$(g.uuid)@#The CRON daemon was not running and could not be restarted";

        crond_restarted::
            "@@Common@@result_repaired@@&TRACKINGKEY&@@CRON Daemon@@None@@$(g.execRun)##$(g.uuid)@#The CRON daemon has been successfully restarted";

        !restart_crond.!crond_restarted.!crond_failed::
            "@@Common@@result_success@@&TRACKINGKEY&@@CRON Daemon@@None@@$(g.execRun)##$(g.uuid)@#The CRON daemon is running";

}

########################################################
# Trash every output report older than 30 days         #
########################################################

bundle agent garbage_collection
{

   files:

       "$(sys.workdir)/outputs" 

           delete => tidy,
           file_select => days_old("30"),
           depth_search => recurse("inf");

       "$(g.rudder_var)/modified-files"

           delete => tidy,
           file_select => days_old("30"),
           depth_search => recurse("inf");

}


#######################################################

body agent control {
    # if default runtime is 5 mins we need this for long jobs
    ifelapsed => "1";

    #define here some environment variables
    environment => { "DEBIAN_FRONTEND=noninteractive" }; 

	abortclasses => { "should_not_continue" };

	agentfacility => "LOG_LOCAL6";

	# Repository where to put the copy of modified files
	linux::
		default_repository => "/var/rudder/modified-files";

}

#######################################################

body executor control {
    splaytime => "1";

    exec_command => "$(sys.cf_agent) -f failsafe.cf && $(sys.cf_agent)";
    schedule         => { "Min00", "Min05", "Min10", "Min15", "Min20", "Min25", "Min30", "Min35", "Min40", "Min45", "Min50", "Min55" };
    executorfacility => "LOG_DAEMON";
}

########################################################

#Enforce that the file only contains this information
bundle edit_line enforce_content(str) {

	delete_lines:
  		"$(str)" not_matching => "true";

	insert_lines:
		"$(str)";
}

body process_count system_check_process_count(name, max, min)
{
    match_range => irange("$(min)","$(max)");
    out_of_range_define => { "$(name)_is_defective" };
}
