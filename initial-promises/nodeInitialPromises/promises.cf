#####################################################################################
# Copyright 2011 Normation SAS
#####################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, Version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#####################################################################################

#######################################################
#
# promises.cf
# 
# This is the bootstrap promises :
# - generate the inventory with the information
# - send it
# - try to retrieve its promises from the server
#######################################################
body common control {

    inputs => {
        "common/1.0/cfengine_stdlib.cf","common/1.0/rudder_lib.cf","common/1.0/process_matching.cf","common/1.0/internal_security.cf","common/1.0/site.cf","common/1.0/update.cf","inventory/1.0/fetchFusionTools.cf","inventory/1.0/virtualMachines.cf","inventory/1.0/fusionAgent.cf"
    };

    bundlesequence => { @(va.bs) , "fetchFusionTools", "virtualMachines", "doInventory" , @(va.end)};
    
    output_prefix => "rudder"; 
    
    host_licenses_paid => "1";

}

bundle common va {
  vars:
    "bs" slist => { "startExecution",  "update", "internal_security", "process_matching", "check_cf_processes", "check_cron_daemon", "garbage_collection", "check_binaries_freshness"
     };


    "end" slist => { "endExecution" };


# definition of the machine roles
# This node doesn't have any specific role
}

#########################################################
# Control execution
#########################################################
bundle agent startExecution {
  reports:
   linux|windows::
       "@@Common@@log_info@@hasPolicyServer-root@@common-root@@00@@common@@StartRun@@$(g.execRun)##$(g.uuid)@#Start execution";
}

bundle agent endExecution {
  reports:
   linux|windows::
       "@@Common@@log_info@@hasPolicyServer-root@@common-root@@00@@common@@EndRun@@$(g.execRun)##$(g.uuid)@#End execution";
}

###################################################
# Check that CFengine services are up 
###################################################
bundle agent check_cf_processes {

processes:

	linux::

		"$(sys.workdir)/bin/cf-serverd"  restart_class => "start_server";
		"$(sys.workdir)/bin/cf-execd"    restart_class => "start_executor";

       "$(sys.workdir)/bin/cf-execd"
           process_count => system_check_process_count("execd", "0","2"),
           signals => { "term", "kill" },
           classes => if_else("execd_is_tame", "execd_has_gone_wild"),
           comment => "Checking if cf-execd has gone wild";

	windows::

       "$(g.escaped_workdir)\/bin\/cf-serverd"  restart_class => "start_server";
       "cf-execd"    restart_class => "start_executor";

       "cf-execd"
           process_count => system_check_process_count("execd", "0","2"),
           signals => { "term" },
           classes => if_else("execd_is_tame", "execd_has_gone_wild"),
           comment => "Checking if cf-execd has gone wild";

commands:

	start_server::
		"$(sys.cf_serverd)"
			action => u_ifwin_bg,
			classes => outcome("server");
	
	start_executor::
		"$(sys.cf_execd)"
			action => u_ifwin_bg,
			classes => outcome("executor");

reports:

    execd_has_gone_wild::

        "@@Common@@result_error@@hasPolicyServer-root@@common-root@@00@@Process checking@@None@@$(g.execRun)##$(g.uuid)@#Warning, too many cf-execd processes were detected. They have been killed.";

}


#######################################################
# Check if the cron daemon is running
# This only works with unix flavoured systems too

bundle agent check_cron_daemon {

    vars:

        (debian|SuSE)::

            "cron_bin" string => "/usr/sbin/cron";
            "cron_restartcmd" string => "/etc/init.d/cron restart";

        redhat::

            "cron_bin" string => "crond";
            "cron_restartcmd" string => "/etc/init.d/crond restart";

    processes:

            "$(cron_bin)"
                restart_class => "restart_crond";

    commands:

        restart_crond::

            "$(cron_restartcmd)"

                comment => "Restarting crond",
                classes => class_trigger("crond_restarted" , "crond_failed", "crond_ok");

    reports:

        crond_failed::
            "@@Common@@result_error@@hasPolicyServer-root@@common-root@@00@@CRON Daemon@@None@@$(g.execRun)##$(g.uuid)@#The CRON daemon was not running and could not be restarted";

        crond_restarted::
            "@@Common@@result_repaired@@hasPolicyServer-root@@common-root@@00@@CRON Daemon@@None@@$(g.execRun)##$(g.uuid)@#The CRON daemon has been successfully restarted";

        !restart_crond.!crond_restarted.!crond_failed::
            "@@Common@@result_success@@hasPolicyServer-root@@common-root@@00@@CRON Daemon@@None@@$(g.execRun)##$(g.uuid)@#The CRON daemon is running";

}

########################################################
# Trash every output report older than 30 days         #
########################################################

bundle agent garbage_collection
{

    files:

        "$(sys.workdir)/outputs"

            delete => tidy,
            file_select => days_old("30"),
            depth_search => recurse("inf");

        "$(g.rudder_var)/modified-files"

            delete => tidy,
            file_select => days_old("30"),
            depth_search => recurse("inf");

}

#######################################################
# Copy the CFengine binaries from the /opt repository
# to the CFengine working directory

bundle agent check_binaries_freshness {

    vars:

        community_edition::

            "components" slist => { "cf-agent", "cf-serverd", "cf-execd", "cf-monitord", "cf-know", "cf-promises", "cf-runagent", "cf-report", "cf-key" };

        nova_edition::

            "components" slist => { "cf-agent", "cf-serverd", "cf-execd", "cf-monitord", "cf-know", "cf-promises", "cf-runagent", "cf-report", "cf-key", "cf-hub" };

    files:

        "${sys.workdir}/bin/${components}"
            perms => u_p("700"),
            copy_from => cp("${g.rudder_sbin}/${components}", "localhost"),
            classes => kept_if_else("binaries_fresh", "binaries_rotten", "binaries_missing"),
            action => immediate,
            comment => "Copying the CFengine binaries from ${g.rudder_sbin}/sbin to ${sys.workdir}/bin";

    reports:

        binaries_fresh.!binaries_rotten.!binaries_missing::
            "@@Common@@result_success@@hasPolicyServer-root@@common-root@@00@@Binaries update@@None@@$(g.execRun)##$(g.uuid)@#The CFengine binaries in ${sys.workdir}/bin are up to date";

        binaries_rotten.!binaries_missing::
            "@@Common@@result_repaired@@hasPolicyServer-root@@common-root@@00@@Binaries update@@None@@$(g.execRun)##$(g.uuid)@#The CFengine binaries have been updated in ${sys.workdir}/bin";

        binaries_missing::
            "@@Common@@result_error@@hasPolicyServer-root@@common-root@@00@@Binaries update@@None@@$(g.execRun)##$(g.uuid)@#An error occurred while updating the CFengine binaries in ${sys.workdir}/bin";

}

#######################################################

body agent control {
    # if default runtime is 5 mins we need this for long jobs
    ifelapsed => "1";

    #define here some environment variables
    environment => { "DEBIAN_FRONTEND=noninteractive" }; 

	abortclasses => { "should_not_continue", "could_not_download_uuid"};
	
	agentfacility => "LOG_LOCAL6";

   # Repository where to put the copy of modified files
    linux::
   default_repository => "/var/rudder/modified-files";

}

#######################################################

body executor control {
    splaytime => "1";

    exec_command => "$(sys.cf_agent) -f failsafe.cf && $(sys.cf_agent)";
    schedule         => { "Min00", "Min05", "Min10", "Min15", "Min20", "Min25", "Min30", "Min35", "Min40", "Min45", "Min50", "Min55" };
    executorfacility => "LOG_DAEMON";
}

#######################################################

#Enforce that the file only contains this information
bundle edit_line enforce_content(str) {

	delete_lines:
  		"$(str)" not_matching => "true";

	insert_lines:
		"$(str)";
}

body process_count system_check_process_count(name, max, min)
{
    match_range => irange("$(min)","$(max)");
    out_of_range_define => { "$(name)_is_defective" };
}
